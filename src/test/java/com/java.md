# 一、并发编程：
## 1.什么是多线程并发和并行？
	并发指的多个线程竞争同一个cpu,先后运行；并行指多核环境下多个线程同时运行
## 2.什么是线程安全问题？
	多个线程同时读写一个共享共享资源，并且没有任何同步措施，导致脏读数据或者其他不可预见的问题
## 3.什么是共享变量的内存可见性问题？
	一个共享变量的修改，能够被其他线程看到
	https://www.jianshu.com/p/ba6992f23f77
## 4.什么是Java中原子性操作？
	执行一系列操作时，这些操作要么全部执行，要么全部不执行，不存在只执行一部分的情况。
## 5.什么是Java中的CAS操作,AtomicLong实现原理？
	CAS即compare and swap,非阻塞行原子操作，AtomicLong利用cas原子性完成的 
## 6.什么是Java指令重排序？
	java内存模型允许编辑器和处理器对指令进行重排序以提高性能，并且只会对不存在数据依赖性的指令重排序。
## 7.Java中Synchronized关键字的内存语义是什么
	1)进入synchronized块的内存语义是把在synchronized块内使用到的共享变量从线程的工作内存中清除，
	    这样在synchronized块内使用到该变量时就不会从线程的工作内存中获取，而是直接从主内存中获取；
	2)退出synchronized块的内存语义是把在synchronized块内对共享变量的修改刷新到主内存。
## 8.Java中Volatile关键字的内存语义是什么？
	当线程写入了volatile变量时把工作内存的变量值同步到主内存，读取volatile变量内存语义是先清除本地内存变量值，再从主内存获取最新值。
## 9.什么是伪共享,为何会出现，以及如何避免？
	cpu内存缓存行的中存在两个变量，两个线程同时对其进行操作时，导致其中一个cpu的失效，重新获取，导致性能降低（Java8之前缓存行填充，Java8之后@sun.misc.Contended直接即可）
## 10.什么是可重入锁、乐观锁、悲观锁、公平锁、非公平锁、独占锁、共享锁？
	悲观锁：synchronized,ReentrantLock
	乐观锁：cas 
	公平锁：先到先运行 ReentrantLock(true)
	非公平锁：抢占，先到不一定先运行 ReentrantLock(false)
	独占锁：只能被一个线程持有 悲观锁
	共享锁：可以被多个线程持有 乐观锁
	可重入锁：线程获取自己已经获取的索引可以再次获取
## 11.讲讲ThreadLocal 的实现原理？
	每个线程内部都有一个名为threadLocals的成员变量，该变量是一个定制化的hashmap,其中key为我们定义的ThreadLocal变量的this引用，value则是我们使用set方法设置的值。
##	 12.说说InheritableThreadLocal 的实现原理？
	inheritableThreadLocals代替了threadLocals，并在Thread初始化的时候把父线程中的inheritableThreadLocals存一份到子线程的inheritableThreadLocals
## 13.随机数生成器 Random 类如何使用 CAS 算法保证多线程下新种子的唯一性？
	用AtomicLong维护一个种子，并是用cas进行更新，然后在根据老种子新的中子，然后根据新的种子来计算新的随机数
## 14.ThreadLocalRandom 是如何利用 ThreadLocal 的原理来解决 Random 的局限性？
	
## 15.Spring 框架中如何使用 ThreadLocal 实现 request scope 作用域 Bean？

## 16.并发包中锁的实现底层（对AQS的理解）？

## 17.讲讲独占锁 ReentrantLock 原理？

## 18.谈谈读写锁 ReentrantReadWriteLock 原理？
	读锁
	写锁
## 19.StampedLock 锁原理的理解？
	每次获取锁的时候都是
## 20.谈下对基于链表的非阻塞无界队列 ConcurrentLinkedQueue 原理的理解？

## 21.ConcurrentLinkedQueue 内部是如何使用 CAS 非阻塞算法来保证多线程下入队出队操作的线程安全？

## 22.基于链表的阻塞队列 LinkedBlockingQueue 原理。

## 23.阻塞队列LinkedBlockingQueue 内部是如何使用两个独占锁 ReentrantLock 以及对应的条件变量保证多线程先入队出队操作的线程安全？

## 24.分析下JUC 中倒数计数器 CountDownLatch 的使用与原理？
    
## 25.CountDownLatch 与线程的 Join 方法区别是什么？
	1. 调用子线程的join()方法后，该线程会被阻塞知道子线程运行完毕，而countDownLatch则使用计数器来允许子线程运行结束或者运行中减数递减，
	   可以在子线程运行的时候让await()方法返回而不一定必须等到线程结束；
	2. 使用线程池来管理线程时一般都是直接添加Runnable到线程池，这个时候join就无法使用了，CountDownLatch 线程同步控制更灵活。
## 26.讲讲对JUC 中回环屏障 CyclicBarrier 的使用？
    让一组线程同时达到一个状态后同时执行，并且重置，且可重用。
## 27.CyclicBarrier内部的实现与 CountDownLatch 有何不同？
    CyclicBarrier 使用的是reentranLock 的独占锁来实现的，parties为记录线程个数，每当有await调用就减一，当计数为0
    CountDownLatch 使用的是 AQS 的共享方式实现的，每次掉用 await 如果 state > 0 则阻塞，当state = 0 是，唤醒全部阻塞线程
## 28.Semaphore 的内部实现是怎样的？
    
## 29.并发组件CopyOnWriteArrayList 是如何通过写时拷贝实现并发安全的 List？
    
# 二、JVM
## 1.Java 内存分配？
	堆、Java虚拟机栈、本地方法栈、程序计数器、方法区（Java8去掉）、直接内存、运行时常量
## 2.Java 堆的结构是什么样子的？
	年轻代（S0,S0,E）、老年代 
## 3.什么是堆中的永久代（Perm Gen space）?
    从永久代到元空间，在小范围自动扩展永生代避免溢出
## 4.说说各个区域的作用？
    Java虚拟机栈：描述Java方法执行的内存模型：每个方法执行的时候同时会创建一个栈帧，
    本地方法栈：虚拟机执行native 方法使用的栈
    程序计数器：当前线程所执行字节码的行号指示器。
    方法区：Java8 之前存在，虚拟机加载的类信息，常量，静态变量，
    元空间：元数据
    堆：
    堆外内存：
## 5.Java 中会存在内存泄漏吗，简述一下？
## 6.Java 类加载过程？    
    加载 --> 验证 -->  准备 -->  解析 --> 初始化
    加载：通过一个类的全限定名来获取定义此类的二进制流；生成Java.lang.Class对象；     
## 7.描述一下 JVM 加载 Class 文件的原理机制?
## 8.什么是类加载器？
## 9.类加载器有哪些？
## 10.什么是tomcat类加载机制？
## 11.类加载器双亲委派模型机制？
## 12.什么是GC? 为什么要有 GC？
## 13.简述一下Java 垃圾回收机制？
## 14.如何判断一个对象是否存活？
## 15.垃圾回收的优点和原理，并考虑 2 种回收机制？
## 16.垃圾回收器的基本原理是什么？
## 17.垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？
## 18.深拷贝和浅拷贝？
    https://www.cnblogs.com/shakinghead/p/7651502.html
## 19.System.gc() 和 Runtime.gc() 会做些什么？
## 20.什么是分布式垃圾回收（DGC）？它是如何工作的？
	RMI 子系统实现基于引用计数的“分布式垃圾回收”(DGC)，以便为远程服务器对象提供自动内存管理设施。
	当客户机创建（序列化）远程引用时，会在服务器端 DGC 上调用 dirty()。
	当客户机完成远程引用后，它会调用对应的 clean() 方法。
	针对远程对象的引用由持有该引用的客户机租用一段时间。租期从收到 dirty() 调用开始。
	在此类租约到期之前，客户机必须通过对远程引用额外调用 dirty() 来更新租约。
	如果客户机不在租约到期前进行续签，那么分布式垃圾收集器会假设客户机不再引用远程对象。
## 21.串行（serial）收集器和吞吐量（throughput）收集器的区别是什么？
## 22.在 Java 中，对象什么时候可以被垃圾回收？
## 23.简述Minor GC 和 Major GC？
## 24.Java 中垃圾收集的方法有哪些？
## 25.讲讲你理解的性能评价及测试指标？
## 26.常用的性能优化方式有哪些？
## 27.说说分布式缓存和一致性哈希？
## 28.同步与异步？阻塞与非阻塞？
## 29.什么是GC调优？
## 30.常见异步的手段有哪些？

# 三、Spring
## 1.为什么需要代理模式？
## 2.讲讲静态代理模式的优点及其瓶颈？
## 3.对Java 接口代理模式的实现原理的理解？
## 4.如何使用 Java 反射实现动态代理？
## 5.Java 接口代理模式的指定增强？
## 6.谈谈对Cglib 类增强动态代理的实现？
## 7.怎么理解面向切面编程的切面？
## 8.讲解OOP与AOP的简单对比？
## 9.讲解JDK 动态代理和 CGLIB 代理原理以及区别？
## 10.讲解Spring 框架中基于 Schema 的 AOP 实现原理？
## 11.讲解Spring 框架中如何基于 AOP 实现的事务管理？
## 12.谈谈对控制反转的设计思想的理解？
## 13.怎么理解 Spring IOC 容器？
## 14.Spring IOC 怎么管理 Bean 之间的依赖关系，怎么避免循环依赖？
## 15.对Spring IOC 容器的依赖注入的理解？
## 16.说说对Spring IOC 的单例模式和高级特性？
## 17.BeanFactory 和 FactoryBean 有什么区别？
## 18.BeanFactory 和 ApplicationContext 又有什么不同？
## 19.Spring 在 Bean 创建过程中是如何解决循环依赖的？
## 20.谈谈Spring Bean 创建过程中的设计模式？

# 四、数据库
## 1.MySQL 有哪些存储引擎啊？都有什么区别？
## 2.Float、Decimal 存储金额的区别？
## 3.Datetime、Timestamp 存储时间的区别？
## 4.Char、Varchar、Varbinary 存储字符的区别？
## 5.对比一下B+树索引和 Hash索引？
## 6.MySQL索引类型有？
## 7.如何管理 MySQL索引？
## 8.对Explain参数及重要参数的理解？
## 9.索引利弊是什么及索引分类？
## 10.聚簇索引和非聚簇索引的区别？
## 11.B+tree 如何进行优化？索引遵循哪些原则？
## 12.索引与锁有什么关系？
## 13.还有什么其他的索引类型，各自索引有哪些优缺点？
## 14.谈谈对Innodb事务的理解？
## 15.说说数据库事务特点及潜在问题？
## 16.什么是MySQL隔离级别？
## 17.有多少种事务失效的场景，如何解决？
## 18.一致性非锁定读和一致性锁定读是什么？
## 19.Innodb如何解决幻读？
## 20.讲讲Innodb行锁？
## 21.死锁及监控是什么？
## 22.自增长与锁 ，锁的算法，锁问题，锁升级是什么？
## 23.乐观锁的线程如何做失败补偿？
## 24.高并发场景（领红包）如何防止死锁，保证数据一致性？
## 25.谈谈MySQL的锁并发？
## 26.查询优化的基本思路是什么？
## 27.说说MySQL读写分离、分库分表？
## 28.表结构对性能有什么影响?
## 29.浅谈索引优化？
## 30.说说Sql优化的几点原则？
## 31.MySQL表设计及规范？
## 32.说说MySQL几种存储引擎应用场景？
## 33.MySQL常用优化方式有哪些？
## 24.MySQL常用监控？
## 25.MySQL瓶颈分析？

# 五、缓存
## 1.redis数据结构有哪些？
## 2.Redis缓存穿透，缓存雪崩？
## 3.如何使用Redis来实现分布式锁？
## 4.Redis的并发竞争问题如何解决？
## 5.Redis持久化的几种方式，优缺点是什么，怎么实现的？
## 6.Redis的缓存失效策略？
## 7.Redis集群，高可用，原理？
## 8.Redis缓存分片？
## 9.Redis的数据淘汰策略？
## 10.redis队列应用场景？
## 11.分布式使用场景（储存session）？

# 六、网络编程
## 1.TCP建立连接和断开连接的过程？
    （1）序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。
    （2）确认序号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。
    （3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：
        （A）URG：紧急指针（urgent pointer）有效。
        （B）ACK：确认序号有效。
        （C）PSH：接收方应该尽快将这个报文交给应用层。
        （D）RST：重置连接。
        （E）SYN：发起一个新连接。
        （F）FIN：释放一个连接。
    建立连接：三次握手 client(SYN=1,seq=J) --> Server(ACK=1,ack=J+1;SYN=1,seq=K) --> client(ACK,ack=K+1)
    断开连接：四次挥手 client(FIN，seq=M) --> Server(ACK,ack=M+1) --> Server(FIN, seq=N) --> Client(ACK,ack=N+1)
## 2.HTTP协议的交互流程，HTTP和HTTPS的差异，SSL的交互流程？
   HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全    
   **HTTPS和HTTP的区别主要如下：**

    1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
    2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
    3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
    4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。   
## 3.TCP的滑动窗口协议有什么用？
滑动窗口协议，是TCP使用的一种流量控制方法。该协议允许发送方在停止并等待确认前可以连续发送多个分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输。  
## 4.HTTP协议都有哪些方法？
    GET:发送请求来获得服务器上的资源，请求体中不会包含请求数据，请求数据放在协议头中。另外get支持快取、缓存、可保留书签等。幂等
    POST:和get一样很常见，向服务器提交资源让服务器处理，比如提交表单、上传文件等，可能导致建立新的资源或者对原有资源的修改。提交的资源放在请求体中。不支持快取。非幂等
    HEAD:本质和get一样，但是响应中没有呈现数据，而是http的头信息，主要用来检查资源或超链接的有效性或是否可以可达、检查网页是否被串改或更新，获取头信息等，特别适用在有限的速度和带宽下。
    PUT:和post类似，html表单不支持，发送资源与服务器，并存储在服务器指定位置，要求客户端事先知道该位置；比如post是在一个集合上（/province），而put是具体某一个资源上（/province/123）。所以put是安全的，无论请求多少次，都是在123上更改，而post可能请求几次创建了几次资源。幂等
    DELETE:请求服务器删除某资源。和put都具有破坏性，可能被防火墙拦截。如果是https协议，则无需担心。幂等
    CONNECT:HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。就是把服务器作为跳板，去访问其他网页然后把数据返回回来，连接成功后，就可以正常的get、post了。
    OPTIONS:获取http服务器支持的http请求方法，允许客户端查看服务器的性能，比如ajax跨域时的预检等。
    TRACE:回显服务器收到的请求，主要用于测试或诊断。一般禁用，防止被恶意攻击或盗取信息。
## 5.Socket交互的基本流程？
    建立连接 --> 发送数据 --> 响应数据  --> 关闭连接
## 6.讲讲tcp协议（建连过程，慢启动，滑动窗口，七层模型）？
    https://www.cnblogs.com/qishui/p/5428938.html
## 7.webservice协议（wsdl/soap格式，与rest协议的区别）？
SOAP：简单对象访问协议，SOAP协议 = HTTP协议 + XML数据格式
REST：表述性状态传递，REST协议 = HTTP协议 + json格式
区别：
    soap以操作为中心，接受xml作为输入，消息通过http传输协议发出，通过RPC调用，再返回一个xml文档。
    soap采用xml文档的消息体，消息的有效负载相对rest的json(当然rest也能用xml等)更少，这点soap相对更重量级。
    rest采用http方法(get，put，post，delete)对URI进行操作，开发简单。
    rest设计原则是无状态的，容易支持负载均衡。
使用场景：    
REST    
    有限的带宽 json更轻量    
    无状态性    
    需要缓存 REST 的应用可以充分地挖掘 HTTP 协议对缓存支持的能力。当客户端第一次发送 HTTP GET 请求给服务器获得内容后，该内容可能被缓存服务器 (Cache Server) 缓存。当下一次客户端请求同样的资源时，缓存可以直接给出响应，而不需要请求远程的服务器获得。对于soap而言，SOAP 消息所使用的 URI 总是指向 SOAP 的服务器，采用缓存，缓存服务器如果不解码 SOAP 消息体，没法知道该 HTTP 请求是否是想从服务器获得数据。    
SOAP    
    安全性要求
    有状态的操作     
## 8.说说Netty线程模型，什么是零拷贝？
https://blog.csdn.net/zguoshuaiiii/article/details/78531491
“零拷贝”是指计算机操作的过程中，CPU 不需要为数据在内存之间的拷贝消耗资源。
而它通常是指计算机在网络上发送文件时，不需要将文件内容拷贝到用户空间（User Space）而直接在内核空间（Kernel Space）中传输到网络的方式。
## 9.TCP三次握手、四次挥手？
    指建立一个TCP连接时，需要客户端和服务器总共发送3个包。
    三次握手的目的是连接服务器指定端口，建立TCP连接,并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息.在socket编程中，客户端执行connect()时。将触发三次握手。
        (1) 第一次握手：建立连接时，客户端A发送SYN包(SYN=J)到服务器B，并进入SYN_SEND状态，等待服务器B确认。
        (2) 第二次握手：服务器B收到SYN包，必须确认客户A的SYN(ACK=J+1)，同时自己也发送一个SYN包(SYN=k)，即SYN+ACK包，此时服务器B进入SYN_RECV状态。
        (3) 第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK(ACK=k+1)，此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。
    完成三次握手，客户端与服务器开始传送数据。

    TCP的连接的拆除需要发送四个包，因此称为四次挥手。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。
    TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。
    收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。
        （1） TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送。
        （2） 服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。
        （3） 服务器关闭客户端的连接，发送一个FIN给客户端。
        （4） 客户端发回ACK报文确认，并将确认序号设置为收到序号加1
## 10.DNS解析过程？
    1.现在我有一台计算机，通过ISP接入了互联网，那么ISP就会给我分配一个DNS服务器，这个DNS服务器不是权威服务器，而是相当于一个代理的dns解析服务器，他会帮你迭代权威服务器返回的应答，然后把最终查到IP返回给你。
    2.现在的我计算机要向这台DNS服务器发起请求查询www.baidu.com这个域名了
    3.ISPDNS拿到请求后，先检查一下自己的缓存中有没有这个地址，有的话就直接返回。这个时候拿到的ip地址，会被标记为非权威服务器的应答。
    4.如果缓存中没有的话，ISPDNS会从配置文件里面读取13个根域名服务器的地址（这些地址是不变的，直接在BIND的配置文件中），
    5.然后像其中一台发起请求。
    6.根服务器拿到这个请求后，知道他是com.这个顶级域名下的，所以就会返回com域中的NS记录，一般来说是13台主机名和IP。
    7.然后ISPDNS向其中一台再次发起请求，com域的服务器发现你这请求是baidu.com这个域的，我一查发现了这个域的NS，那我就返回给你，你再去查。
    （目前百度有4台baidu.com的顶级域名服务器）。
    8.ISPDNS不厌其烦的再次向baidu.com这个域的权威服务器发起请求，baidu.com收到之后，查了下有www的这台主机，就把这个IP返回给你了，
    9.然后ISPDNS拿到了之后，将其返回给了客户端，并且把这个保存在高速缓存中。       
## 11.TCP如何保证数据的可靠传输的？                                                  
    1、将数据截断为合理的长度
        应用数据被分割成TCP认为最适合发送的数据块。这和UDP完全不同，应用程序产生的数据报长度将保持不变.  
    2、超时重发
        当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。
    3、对于收到的请求，给出确认响应
        当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒(之所以推迟，可能是要对包做完整校验) 。
    4、校验出包有错，丢弃报文段，不给出响应，TCP发送数据端，超时时会重发数据
        TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。
    5、对失序数据进行重新排序，然后才交给应用层
        既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。如果必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。 
    6、对于重复数据，能够丢弃重复数据
        既然IP数据报会发生重复，TCP的接收端必须丢弃重复的数据。
    7、TCP可以进行流量控制，防止较快主机致使较慢主机的缓冲区溢出
        TCP还能提供流量控制。TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。TCP使用的流量控制协议是可变大小的滑动窗口协议。
## 12.为什么连接的时候是三次握手，关闭的时候却是四次握手？
因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。
## 13.为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？
虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。
为什么是2MSL，主要是为了考虑到如果最后一个ACK丢失，服务端会重新发FIN，客户端等待2MSL，才能接收到服务端重新发送的FIN报文。


# 七、分布式
## 1.什么是CAP定理？
Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性）	
CAP三个特性只能满足其中两个，那么取舍的策略就共有三种：
    
    CA without P：如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。
                 但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，没办法部署子节点，这是违背分布式系统设计的初衷的。
    
    CP without A：如果不要求A（可用），相当于每个请求都需要在服务器之间保持强一致，而P（分区）会导致同步时间无限延长(也就是等待数据同步完才能正常访问服务)，
                 一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。
                 设计成CP的系统其实不少，最典型的就是分布式数据库，如Redis、HBase等。对于这些分布式数据库来说，数据的一致性是最基本的要求，
                 因为如果连这个标准都达不到，那么直接采用关系型数据库就好，没必要再浪费资源来部署分布式数据库。
    
    AP wihtout C：要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。
                 典型的应用就如某米的抢购手机场景，可能前几秒你浏览商品的时候页面提示是有库存的，当你选择完商品准备下单的时候，系统提示你下单失败，商品已售完。
                 这其实就是先在 A（可用性）方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，虽然多少会影响一些用户体验，但也不至于造成用户购物流程的严重阻塞。

## 2.说说CAP理论和BASE理论？
    BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的缩写
    * BASE理论是对CAP中**一致性C和可用A**性的权衡总结.
    Basically Available: 分布式系统在出现故障时，允许**损失部分可用性**，但是系统还是可用的.
    Soft state: 和ACID强状态相对应，是指系统中允许存在的**中间状态**;不会影响系统的整体可用性.
    Eventually consistent: 系统中的数据，经过同步之后最终能够达到一个一致的状态.
## 3.什么是最终一致性？最终一致性实现方式？
    2PC（Two Phase Commit）两阶段提交:一般说的两阶段提交是基于XA协议的。另外JTA协议的也比较常见。
    　　XA是一个分布式事务协议。它大致分为两部分：事务管理器和本地资源管理器。
        其中本地资源管理器往往由数据库实现，比如Oracle、DB2都实现了XA接口。
        MySQL对XA的支持不是很好。而事务管理器作为全局的调度者，负责各个本地资源的提交和回滚。
        两阶段提交的优点是：原理简单、实现方便。缺点是同步阻塞、单点问题、数据不一致。
    3PC(Three Phrase Commit)三阶段提交：分为CanCommit、PreCommit、Do Commit 三个阶段。就是把两阶段提交的Phase 1分成两个，预提交的时候如果有参与者返回No或者超时则中断事务。
    　　三阶段提交的优点是降低参与者阻塞范围，并能够在出现单点故障后继续达成一致。缺点是因为preCommit阶段，在这个阶段如果出现网络分区，协调者无法与参与者正常通信，参与者仍然会进行实物提交，造成数据不一致。
    TCC(Try-Confirm-Cancel) 
       Try:完成所有的检查，预留必须资源
       Confirm:使用Try阶段预留的资源执行业务，如果执行出现异常，要重试　　  
       Cancel:释放Try阶段预留资源
       TCC能够对分布式事务中的各个资源进行分别锁定，分别提交与释放。适用于严格一致、执行时间短、实时性要求高的场景。
    Paxos算法：实现比较复杂，Zookeeper就是用这个来实现的分布式一致性。
        Paxos算法、Raft协议和Zab（Zookeeper Atomic Broadcast）协议都是一种通过多数投票来保证主备数据一致性的。
    ISR（In-Sync Replicas）机制：Kafka使用了这个机制来保证数据一致性。
        ISR认为对于2f+1个副本来说，多数投票机制要求最多只能允许f个副本发生故障，如果要支持2个副本的容错，则需要至少维持5个副本。
## 4.什么是一致性Hash？
## 5.讲讲分布式事务？
## 6.如何实现分布式锁？
    MYSQL,Redis.zookeeper
## 7.如何实现分布式 Session?
## 8.如何保证消息的一致性?
## 9.负载均衡的理解？
## 10.正向代理和反向代理？
## 11.CDN实现原理？
## 12.怎么提升系统的QPS和吞吐？
## 13.Dubbo的底层实现原理和机制？
## 14.描述一个服务从发布到被消费的详细过程？
## 15.分布式系统怎么做服务治理？
## 16.消息中间件如何解决消息丢失问题？
## 17.Dubbo的服务请求失败怎么处理？
## 18.对分布式事务的理解？
## 19.如何实现负载均衡,有哪些算法可以实现?
## 20.Zookeeper的用途,选举的原理是什么?
    
## 21.讲讲数据的垂直拆分水平拆分？
## 22.zookeeper原理和适用场景？
    Zookeeper 的核心是原子广播，这个机制保证了各个Server之间的同步。
    实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。
    当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和 leader的状态同步以后，恢复模式就结束了。
    状态同步保证了leader和Server具有相同的系统状态。
## 23.zookeeper watch机制？
    Watch机制官方声明：一个Watch事件是一个一次性的触发器，当被设置了Watch的数据发生了改变的时候，则服务器将这个改变发送给设置了Watch的客户端，以便通知它们。
    Zookeeper机制的特点：
    1、一次性触发数据发生改变时，一个watcher event会被发送到client，但是client只会收到一次这样的信息。
    2、watcher event异步发送watcher的通知事件从server发送到client是异步的，这就存在一个问题，不同的客户端和服务器之间通过socket进行通信，
        由于网络延迟或其他因素导致客户端在不通的时刻监听到事件，由于Zookeeper本身提供了ordering guarantee，即客户端监听事件后，才会感知它所监视znode发生了变化。
        所以我们使用Zookeeper不能期望能够监控到节点每次的变化。Zookeeper只能保证最终的一致性，而无法保证强一致性。
    3、数据监视Zookeeper有数据监视和子数据监视getdata() and exists()设置数据监视，getchildren()设置了子节点监视。
    4、注册watcher getData、exists、getChildren
    5、触发watcher create、delete、setData
    6、setData()会触发znode上设置的data watch（如果set成功的话）。一个成功的create() 操作会触发被创建的znode上的数据watch，
        以及其父节点上的child watch。而一个成功的delete()操作将会同时触发一个znode的data watch和child watch（因为这样就没有子节点了），同时也会触发其父节点的child watch。
    7、当一个客户端连接到一个新的服务器上时，watch将会被以任意会话事件触发。当与一个服务器失去连接的时候，是无法接收到watch的。
        而当client重新连接时，如果需要的话，所有先前注册过的watch，都会被重新注册。通常这是完全透明的。
        只有在一个特殊情况下，watch可能会丢失：对于一个未创建的znode的exist watch，如果在客户端断开连接期间被创建了，并且随后在客户端连接上之前又删除了，这种情况下，这个watch事件可能会被丢失。
    8、Watch是轻量级的，其实就是本地JVM的Callback，服务器端只是存了是否有设置了Watcher的布尔类型
## 24.redis/zk节点宕机如何处理？    
    现在有主从结构，主库没有配置持久化，从库配置AOF。哪一天主库突然宕了，怎么办？
    要知道这样一来，最坏情况数据将全部丢失。
    因为主库没有配置持久化，所以主库的data目录只有从库连接主库请求resync的时候做快照留下来的dump.rdb文件。
    如果重启主库，主库会按照data目录下的dump.rdb来恢复数据。
    因此，如果从库是从最开始就配置好了的而且没有发生过再次请求resync，那么此时的dump.rdb将是空的。
    主库按照空的dump.rdb恢复数据，自然数据全无，从库发现主库能够连接上时会自动请求resync,从库也将拷贝一份空白的数据。
    这个时候怎么办呢？连上从库，做save操作。将会在从库的data目录保存一份从库最新的dump.rdb文件。将这份dump.rdb文件拷贝到主库的data目录下。再重启主库。
    
    Zookeeper本身也是集群，推荐配置不少于3个服务器。Zookeeper自身也要保证当一个节点宕机时，其他节点会继续提供服务。
    如果是一个Follower宕机，还有2台服务器提供访问，因为Zookeeper上的数据是有多个副本的，数据并不会丢失；
    如果是一个Leader宕机，Zookeeper会选举出新的Leader。
    ZK集群的机制是只要超过半数的节点正常，集群就能正常提供服务。只有在ZK节点挂得太多，只剩一半或不到一半节点能工作，集群才失效。
    所以
    3个节点的cluster可以挂掉1个节点(leader可以得到2票>1.5)
    2个节点的cluster就不能挂掉任何1个节点了(leader可以得到1票<=1)
## 25.分布式集群下如何做到唯一序列号？
    zookeeper采用了递增的事务Id来标识，所有的proposal（提议）都在被提出的时候加上了zxid，
    zxid实际上是一个64位的数字，高32位是epoch（时期; 纪元; 世; 新时代）用来标识leader是否发生改变，
    如果有新的leader产生出来，epoch会自增，低32位用来递增计数。
    当新产生proposal的时候，会依据数据库的两阶段过程，首先会向其他的server发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行
## 26.用过哪些MQ,怎么用的,和其他mq比较有什么优缺点,MQ的连接是线程安全的吗？
    https://blog.csdn.net/chang384915878/article/details/86741181
## 27.MQ系统的数据如何保证不丢失？
## 28.列举出能想到的数据库分库分表策略？


4.hbase的rowkey 设计？ 

5.MongoDB与es的做聚合运算的区别？

6.es的倒排索引与正排索引的区别？
7.怎么编写一个sparkStreaming程序？
9.怎么在redis中查下午2点~4点的数据 
10.如何用shell命令替换1234 为abc ? 
11.jps 下面有很多进程，如何用一条命令全部杀死？
12.scala 如何实现 a.方法？ 比如实现截取的方法，用.来调用。
13.spark 中如果接入一个redis连接对象，放什么位置？如果是在partion中，多次的创建浪费资源，如何避免？

2、你们项目中微服务是怎么划分的，划分粒度怎么确定？

3、那在实践微服务架构中，有遇到什么问题么？

4、你们在关于微服务间数据一致性问题，是如何解决的？

5、你们为什么不用其他的MQ,最终选择了RocketMQ？

6、为什么RocketMQ没有选择ZooKeeper，而是自己实现了一个NameServer集群？

7、嗯，理解的不错，Zookeeper在选举的过程中，还能对外提供服务么？

8、对Paxos算法了解多少？

9、如果让你来设计一个春晚抢红包架构，你会怎么设计？

1、扯了下项目、讲一下项目经历

2、你们用了redis，redis的底层数据结构了解多少？

http://www.cnblogs.com/jaycekon/p/6227442.html
http://www.cnblogs.com/jaycekon/p/6277653.html

3、知道动态字符串sds的优缺点么？
注:sds为redis底层数据结构之一  http://www.cnblogs.com/jaycekon/p/6227442.html

4、redis的单线程特性有什么优缺点？
https://www.cnblogs.com/shamo89/p/8352084.html
https://blog.csdn.net/weixin_42295141/article/details/81380633

5、用过 Redis 的哪些数据结构, 分别用在什么场景?
	String  缓存 常规计数：微博数，粉丝数等 共享session
	hash 用户信息，商品信息
	list 微博的关注列表，粉丝列表，最新消息排行等功能
	set 共同好友，二度好友，tag交集,去重
	sortSet 排行榜
	https://blog.csdn.net/QIAOBAO2018/article/details/80925083

6、你们怎么解决缓存击穿问题的？
缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。
如何避免？
对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃。还有最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。
也可以采用一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。

缓存雪崩是指如果缓存集中在一段时间内失效，发生大量的缓存穿透，所有的查询都落在数据库上，造成了缓存雪崩。
如何避免？
在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。
可以通过缓存reload机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存
做二级缓存，或者双缓存策略。A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期。
这个没有完美解决办法，但可以分析用户行为，尽量让失效时间点均匀分布。
大多数系统设计者考虑用加锁或者队列的方式保证缓存的单线程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。

7、Hystrix的隔离机制有哪些？Hystrix常见配置是哪些？
https://www.cnblogs.com/lexiaofei/p/7761982.html
8、自己做过哪些调优？JVM调优、数据库调优都行！


2、平时会用到哪些数据结构？

3、链表和数组的优缺点？

4、解决hash冲突的方法有哪些？
开放地址法、
5、讲讲自己对HashMap的理解，以及和Weakhashmap的区别？

6、你刚才讲的是JDK1.7版本的实现，知道JDK1.8做了哪些改动么？

7、你们在微服务中用RPC通信还是REST？

8、RPC和HTTP的关系是什么？

9、知道HTTP1.0和1.1的区别么？

10、谈谈什么是HTTP的长连接和短连接？

11、TCP的三次握手和四次挥手，以及为什么要三次握手，而不是二次？

12、TCP 有哪些状态，相应状态的含义

13、让你评价一下你自己？

2、你们数据库的高可用架构是怎么样的？

3、如何保证数据库主从一致性？

4、知道mysql的索引算法么？

5、为什么mongodb的索引用了B树，而mysql用B+树？

6、用mysql过程中，有遇到什么问题么？

7、你们生产用的是哪种事务隔离级别，为什么？

8、谈一谈你对微服务架构的理解

9、你用过哪些RPC框架，讲讲他们优缺点

10、用过docker么，对容器了解多少

#### 如何设计一个秒杀系统？要考虑什么？
    -- 瞬时并发高
    -- 超卖问题
    -- 性能
    前端：页面静态化 + CDN 、 禁止重复提交 、 用户限流（一段时间内只能提交一次）
    后端：服务限流降级、限制单个用户的访问频率、库存相关的读请求放入缓存、MQ、数据库在分表。
    缓存，异步，限流



